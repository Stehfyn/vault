

















































































































































































































































































































































































































































































































































 < start) {
        return sv;
    }

    return sv.substr(start, end - start + 1);
}

constexpr auto remove_namespaces(std::string_view sv) {
    auto last = sv.find_last_of(':');
    if (last == std::string_view::npos) {
        return sv;
    }
    return sv.substr(last + 1, sv.size() - (last + 1) - 1);
}

template <typename T>
constexpr auto make_type_name() {
    return parse_type(func_sig<T>());
}

template <typename T>
constexpr auto make_type_name_minimal() {
    return remove_namespaces(parse_type(func_sig<T>()));
}

template <typename T>
constexpr auto make_type_name_full() {
    return func_sig<T>();
}

unsigned constexpr const_hash(std::string_view sv) {
    return *sv.data() ?
        static_cast<unsigned int>(*sv.data()) + 33 * const_hash(sv.data() + 1) :
        5381;
}

template <typename T> struct type_hash {
    static constexpr unsigned int hash{const_hash(make_type_name<T>())};
    static constexpr std::string_view name{make_type_name<T>()};
    static constexpr std::string_view name_minimal{make_type_name_minimal<T>()};
    static constexpr std::string_view name_full{make_type_name_full<T>()};
};

template <typename evt> static constexpr auto id = utility::type_hash<evt>::hash;
}

struct read_only {
    std::optional<int> x;
    std::optional<int> y;
};

class context{
    public:
    std::reference_wrapper<const read_only> data() const {
        return std::cref(data_);
    };
    private:
        read_only data_;
};


int main() {

    context ctx;

    const auto& data = ctx.data().get();

    std::cout << utility::type_name<decltype(data)>() << std::endl;

    if(data.x){
        std::cout << data.x.value() << std::endl;
    } else {
        std::cout << "data.x has no value" << std::endl;
    }

    const auto data1 = ctx.data().get();

    if(data1.x){
        std::cout << data1.x.value() << std::endl;
    } else {
        std::cout << "data.x has no value" << std::endl;
    }
}
```
[https://godbolt.org/z/TjMKx7Y3P](https://godbolt.org/z/TjMKx7Y3P "https://godbolt.org/z/TjMKx7Y3P")